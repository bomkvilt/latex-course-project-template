%%% ----------------------------------------------------------------- %%%
%%  Since the framework uses independent packages and semi-independent 
%   in-package modules it's nessesery to be able to use package and 
%   module-relative include (input) paths for convenience reasons. 
%   The necessity gets more urgent becouse of the framework's nature:
%   the one is a git-module must be able to be used with one simple 
%   python script.
% 
%   Since a document root relative path is various predefined path cannot
%   be used here. To sove the problem of path derivatoin it's nessesery
%   to generate the path on-a-flight.
% 
%   To make it done it might be convenient to redefine already existing
%   include/input command and add force them to push new directories into
%   a path stack and update '__file__' and '__dir__' variables.
% 
%   The package upgrades the following default commands:
%       - input | include   - force them to update specific variables
%       - usepackage        - prevents secondary package usage
%
%   The command are available for use:
%       - \curfile          - main document's root relative path to a current .tex file
%       - \curdir           - main document's root relative path to a current .tex file's directory

% LaTeX3 support >> on
\usepackage{expl3 }
\usepackage{xparse}
\usepackage{xargs }

\ExplSyntaxOn
\makeatletter

% -----------------| include guard

\cs_if_free:NTF \pack@g@lockGuard {
    \bool_new:N       \pack@g@lockGuard
    \bool_gset_true:N \pack@g@lockGuard
} {
    \typeout{Error: package module cannot be included twice}
    \stop
}

\usepackage{etoolbox}


% -----------------| include and input

\let\pack@old@include \include
\let\pack@old@input   \input


% replaces a default \include and extends it's functionality
% @path - file or document root relative file path
\RenewDocumentCommand{\include}{ m } {
    \regex_match:nnTF {^\./} {#1} 
    { \pack@doInsert:Nn \pack@old@include {  #1} } 
    { \pack@doInsert:Nn \pack@old@include {./#1} }
}

% replaces a default \input and extends it's functionality
% @path - file or document root relative file path
\RenewDocumentCommand{\input}{ m } {
    \pack@doInsert:Nn \pack@old@input {#1}
}

% backup new commands versions
\let\pack@new@include \include
\let\pack@new@input   \input

% return 
\NewDocumentCommand{\curfile}{} {
    \str_use:N \pack@g@fullPath_str
}

\NewDocumentCommand{\curdir}{} {
    \str_use:N \pack@g@fullRoot_str
}


% -----------------| usepackage

\let\pack@old@usepackage \usepackage


\RenewDocumentCommand{\usepackage}{ s o m } {
    \ifinlist {#3} {\pack@g@usedPackages_seq} {
        % empty
    } {
        % mark as included
        \seq_gpush:Nn \pack@g@usedPackages_seq {#3}

        % set basic include commands
        \let\include \pack@old@include
        \let\input   \pack@old@input

        % include
        \IfNoValueTF {#2} 
        { \pack@old@usepackage    {#3} } 
        { \pack@old@usepackage[#2]{#3} }

        % set new include commands
        \let\include \pack@new@include
        \let\input   \pack@new@input
    }
}


% -----------------| private:

\str_new:N \pack@TRUE
\str_new:N \pack@FALSE
\str_gset:Nn \pack@TRUE  {true}
\str_gset:Nn \pack@FALSE {false}


% current values
\str_new:N \pack@g@fullRoot_str
\str_new:N \pack@g@fullPath_str
\str_new:N \pack@g@brelPath_str
\str_gset_eq:NN \pack@g@brelPath_str \pack@TRUE

% list of include directories
\seq_new:N \pack@g@rootStack_seq
\seq_new:N \pack@g@fileStack_seq
\seq_new:N \pack@g@bRelStack_seq
\seq_gput_right:Nn \pack@g@rootStack_seq {}
\seq_gput_right:Nn \pack@g@fileStack_seq {}
\seq_gput_right:Nx \pack@g@bRelStack_seq {\pack@g@brelPath_str}



% use a specified command to insert a spicified file 
% @insertion_command    - include | imput
% @insertion_path       - file | document relative path
\tl_new:N   \l_tmp_tl
\seq_new:N  \l_pathParts_seq
\seq_new:N  \l_rootParts_seq
\str_new:N  \l_rootPath_str
\str_new:N  \l_filePath_str
\bool_new:N \l_bRelInclude
\cs_new_protected:Npn \pack@doInsert:Nn #1 #2 {
    % deduce new stacks' top values
    \group_begin:
        % check if the path is a file-relative one
        \regex_match:nnTF {^\./} {#2} {
            \str_if_eq:NNF {\pack@g@brelPath_str} {\pack@TRUE} {
                \PackageError{Error:~Local~includes~can~only~be~be~in~a~local~include~chain}
                \stop
            }
            % split a passed path onto '/'-devided parts
            \seq_set_split:Nnn \l_pathParts_seq {/}{#2}
            \seq_pop_left:NN   \l_pathParts_seq \l_tmp_tl
            % deduce a file name and a root path parts
            \seq_set_eq:NN     \l_rootParts_seq \l_pathParts_seq
            \seq_pop_right:NN  \l_rootParts_seq \l_fileName_tl
            % make the paths document-relative
            \seq_put_left:Nx   \l_rootParts_seq {\pack@g@fullRoot_str}
            \seq_put_left:Nx   \l_pathParts_seq {\pack@g@fullRoot_str}
            \seq_remove_all:Nn \l_rootParts_seq {}
            \seq_remove_all:Nn \l_pathParts_seq {}
            % convert them to '/'-devided strings
            \str_set:Nx \l_rootPath_str {\seq_use:Nnnn \l_rootParts_seq {/}{/}{/}}
            \str_set:Nx \l_filePath_str {\seq_use:Nnnn \l_pathParts_seq {/}{/}{/}}
            \bool_set_true:N \l_bRelInclude
        } {
            \str_set:Nx \l_rootPath_str {}
            \str_set:Nx \l_filePath_str {#2}
            \bool_set_false:N \l_bRelInclude
        }

        % push current variables (start a new frame)
        \seq_gput_right:Nx \pack@g@rootStack_seq {\l_rootPath_str}
        \seq_gput_right:Nx \pack@g@fileStack_seq {\l_filePath_str}
        \seq_gput_right:Nx \pack@g@bRelStack_seq {\l_bRelInclude }
        \pack@actualizeVariables:
    \group_end:

    % insert the specified file
    #1{\curfile}

    % pop current variables (close the frame)
    \seq_gpop_right:NN \pack@g@rootStack_seq \l_tmp_tl
    \seq_gpop_right:NN \pack@g@fileStack_seq \l_tmp_tl
    \seq_gpop_right:NN \pack@g@bRelStack_seq \l_tmp_tl
    \pack@actualizeVariables:
}

% place top elements from stacks to destination variables
\cs_new_protected:Npn \pack@actualizeVariables: {
    \pack@actualizeVariable:NN \pack@g@rootStack_seq \pack@g@fullRoot_str
    \pack@actualizeVariable:NN \pack@g@fileStack_seq \pack@g@fullPath_str
    \pack@actualizeVariable:NN \pack@g@bRelStack_seq \pack@g@bRelative
}

% place a top element from the stack to the destination variable
% @source_stack     - a stack (sequence) to get a top element
% @destination_var  - a variable to be assigned globaly
\cs_new_protected:Npn \pack@actualizeVariable:NN #1 #2 {
    \group_begin:
        \seq_get_right:NN #1  \l_tmp_tl
        \str_gset:Nx      #2 {\l_tmp_tl}
    \group_end:
}


\seq_new:N \pack@g@usedPackages_seq

% use a specified cammand to import a specified package with specified arguments
% @command
% @package
% @args
\cs_new_protected:Npn \pack@doUsePackage:NNn #1 #2 #3 {
    \ifinlist {#2} {\pack@g@usedPackages_seq} {
        % empty
    } {
        % mark as included
        \seq_gpush:Nn \pack@g@usedPackages_seq {#2}

        % include
        % #1[#3]{#2}
        \pack@old@usepackage{import}
    }
}


% LaTeX3 support >> off
\makeatother
\ExplSyntaxOff
